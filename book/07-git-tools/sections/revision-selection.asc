[[_revision_selection]]
=== Pagpipili ng Rebisyon

Ang Git ay nagpapahintulot sa iyo upang sumangguni sa isang itinakdang mga commit o isang lawak ng mga commit sa maraming mga paraan.
Hindi nila kinakailangan na halata ngunit nakakatulong upang malaman.

==== Solong mga Rebisyon

Maaari mong malinaw na i-refer ang anumang solong commit sa buong ito, 40-karakter na SHA-1 hash, ngunit may mga higit pa na pantaong-palakaibigan na mga paraan upang sumangguni rin sa mga commit.
Ang seksyon na ito ng mga outline ng iba't ibang mga paraan na maaari mong isangguni sa anumang commit.

==== Ang Maikling SHA-1

Ang Git ay sapat na matalino upang malaman kung anong commit ang iyong nare-refer na kung bigyan mo ang mga unang ilang mga karakter ng SHA-1 hash, hangga't ang bahagyang hash ay hindi bababa sa apat na mga karakter ang haba at hindi malabo; yan ay, walang ibang bagay sa database ng bagay na maaaring magkakaroon ng hash na nagmumula ng parehong prefix.

Halimbawa, upang suriin ang tiyak na commit na kung saan ka kilala mo ang dinagdag na ilang mga pag-andar, maaari mong patakbuhin muna ang `git log` na utos upang hanapin ang commit:

[source,console]
----
$ git log
commit 734713bc047d87bf7eac9674765ae793478c50d3
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'

commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff
----

Sa kasong ito, sabihin mong interesado ka sa commit na kanino ang hash nagsisimula ng `1c002dd...`.
Maaari mong siyasatin ang commit na may anumang sumusunod na mga pagkakaiba-iba sa `git show` (ipagpalagay na mas maikling mga bersyon ay hindi malabo):

[source,console]
----
$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
$ git show 1c002dd4b536e7479f
$ git show 1c002d
----

Maaaring malaman ng Git ang isang maikli, natatanging pagpapaiklipara sa iyong SHA-1 na mga halaga.
Kung ikaw ay nagpasa ng `--abbrev-commit` sa `git log` na utos, ang output ay gumamit ng mas maikling halaga ngunit panatilihin sila na katangi-tangi; ito ay mga default sa paggamit ng pitong mga karakter ngunit ginagawa nila ito na mas matagal kung kinakailangan upang mapanatiling hindi malinaw ang SHA-1:

[source,console]
----
$ git log --abbrev-commit --pretty=oneline
ca82a6d changed the version number
085bb3b removed unnecessary test code
a11bef0 first commit
----

Sa pangkalahatan, walo sa sampung mga karakter ay higit pa sa sapat upang maging natatanging sa loob ng isang proyekto.
Halimbawa, sa Oktubre 2017, ang Linux na kernel (na kung saan ay isang medyo malaki na proyekto) ay may higit sa 700,000 na mga commit at halos anim na milyong na mga bagay, na may walang dalang mga bagay na magkatulad ang mga SHA-1 ay magkapareho sa unang 11 na mga karakter.

[TANDAAN]
.ISANG MAIKLING PAALALA TUNGKOL SA SHA-1
====

Maraming tao ay magiging nababahala sa isang punto na sila ay, sa pamamagitan ng sapalaran na pagkakataon, mayroong dalawang magkakaibang bagay sa kanilang repositoryo na ang hash ay pareho sa SHA-1 na halaga.
Ano ngayon?

Kung mangyari na ikaw ay mag-commit sa isang bagay na nag-hash sa parehong SHA-1 na halaga bilang isang nakaraang _ibang_ bagay sa iyong repositoryo, Ang Git ay makakita ng nakaraan na bagay na nasa iyong Git na database, ipagpalagay na ito ay nakasulat na at muli lang gamitin ito.
Kung subukan mong tingnan ang bagay na iyon muli sa isang punto, ikaw ay makakakuha lagi ng datos sa unang bagay.

Gayunpaman, dapat mong malaman kung gaano katawa ang pagkawala sa sitwasyon na ito.
Ang SHA-1 na digest ay 20 bytes o 160 bits.
Ang bilang ng random na naka-hash na mga bagay na kinakailangan siguraduhin ang 50% na posibilidad ng isang banggaan ay mga 2^80^
(ang formula para sa pagtukoy ng posibilidad ng banggaan ay `p = (n(n-1)/2) * (1/2^160))`. 2^80^
ay 1.2 x 10^24^
o 1 milyon bilyon bilyon.
Iyon ay 1,200 na beses ang bilang ng mga butil ng buhagin sa lupa.

Narito ang isang halibawa na magbibigay sa iyo ng ideya kung ano ang kukuha nitong SHA-1 na banggaan
Kung lahat sa 6.5 na bilyon na mga tayo sa Lupa ay nag-program, sa bawat segundo, sa bawat isa ay gumagawa ng code na katumbas sa buong Linux na kernel na kasaysayan(3.6 na milyong Git na mga bagay) at itinutulak into sa isang napakalaking Git na repositoryo, ito ay kukuha ng halos dalawang taon hanggang ang repositoryong ito ay maglalaman ng sapat na mga bagay upang magkaroon ng 50% na posibilidad sa isang SHA-1 na bagay na banggaan.
Kaya naman, ang SHA-1 na banggaan ay mas malamang kaysa sa bawat miyembro sa iyong programming na koponan na inatake o napatay ng mga lobo sa hindi nauugnay na insidente sa parehong gabi.

====

[[_branch_references]]
==== Mga Reperensiya ng Branch

Isang tapat na paraan upang i-refer ang isang partikular na commit na kung itong commit na nasa tuktok na isang branch; sa ganitong kaso, maaari mo lamang gamitin ang pangalan ng branch sa anumang Git na utos na inaasahan ng isang reperensiya sa isang commit.
Halimbawa, kung gusto mong suriin ang huling commit sa bagay sa branch, ang sumusunod na mga utos ay katumbas, ipagpalagay na ang `topic1` na branch ay tumuturo sa commit sa `ca82a6d...`:

[source,console]
----
$ git show ca82a6dff817ec66f44342007202690a93763949
$ git show topic1
----

Kung gusto mong makita kung saang tiyak na SHA-1 na branch tumuturo ito, o kung gusto mong makita ang kung anumang mga halimbawang ito na bumababa sa termino ng SHA-1s, maaari kang gumamit ng Git plumbing na kasangkapan na tinatawag na `rev-parse`.
You can see <<_git_internals#_git_internals>> for more information about plumbing tools; basically, `rev-parse` exists for lower-level operations and isn’t designed to be used in day-to-day operations.
Gayunpaman, maaari itong makakatulong kung minsan kapag ikaw ay nangangailangan upang makita kung ano talaga ang nangyayari.
Dito maaari kang magpatakbo ng `rev-parse` sa iyong branch.

[source,console]
----
$ git rev-parse topic1
ca82a6dff817ec66f44342007202690a93763949
----

[[_git_reflog]]
==== Mga Shortname ng RefLog

Isa sa mga bagay ng Git ay gumawa ng background habang ikaw ay nagtratrabaho ng malayo ay magtago ng ``reflog'' -- isang log na kung saan ang iyong HEAD at branch na mga reperensiya ay para sa huling ilang mga buwan.

Maaari mong makita ang iyong reflog sa pamamagitan ng paggamit ng `git reflog`:

[source,console]
----
$ git reflog
734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated
d921970 HEAD@{1}: merge phedders/rdocs: Merge made by the 'recursive' stategy.
1c002dd HEAD@{2}: commit: added some blame and merge stuff
1c36188 HEAD@{3}: rebase -i (squash): updating HEAD
95df984 HEAD@{4}: commit: # This is a combination of two commits.
1c36188 HEAD@{5}: rebase -i (squash): updating HEAD
7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD
----

Sa tuwing iyong branch tip ay na-update sa anumang rason, ang Git ay nag-iimbak ng impormasyon para sa iyong temporaryong kasaysayan.
Maaari mong gamitin ang iyong reflog na datos upang i-refer din ang mga lumang mga commit.
Halimbawa, kung ikaw ay gustong makakita ng panglimang bago ang halaga sa HEAD ng iyong repositoryo, maaari mong gamitin ang `@{5}` na reperensiya na nakikita mo sa reflog output:

[source,console]
----
$ git show HEAD@{5}
----

Maaari mo ding gamitin ang syntax na ito upang makita kung saan ang branch ay ilang dami ng oras ang nakalipas.
Halimbawa, para makita kung saan ang iyong `master` na branch kahapon, maaari kang mag-type ng

[source,console]
----
$ git show master@{yesterday}
----

Iyon ay magpapakita sa iyo kung saan ang tip ng iyong `master` na branch kahapon.
Ang pamamaraan na ito ay gumagana lamang para sa datos na nasa iyong reflog pa, kaya ikaw ay hindi makagamit nito ng mga commit na mas luma pa sa ilang mga buwan.

Upang makita ang reflog na impormasyon na naka-format tulad ng `git log` na output, maaari kang magpatakbo ng `git log -g`:

[source,console]
----
$ git log -g master
commit 734713bc047d87bf7eac9674765ae793478c50d3
Reflog: master@{0} (Scott Chacon <schacon@gmail.com>)
Reflog message: commit: fixed refs handling, added gc auto, updated
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Reflog: master@{1} (Scott Chacon <schacon@gmail.com>)
Reflog message: merge phedders/rdocs: Merge made by recursive.
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'
----

Mahalagang tandaan na ang reflog na impormasyon ay mahigpit na lokal -- ito ay isang log lamang kung ano _ang iyong_ nagawa sa _iyong_ repositoryo.
Ang mga reperensiya ay hindi pareho sa ibang kopya ng repositoryo; saka, pagkatapos ka mag-clone ng repositoryo, ikaw ay magkakarooon ng walang laman na reflog, na bilang walang aktibidad na naganap pa sa iyong repositoryo.
Pagtatakbo ng `git show HEAD@{2.months.ago}` ay ipapakita sa iyo ang pagtutugma ng commit lamang kung ikaw ay nag-clone ng proyekto na hindi bababa sa dalawang buwan na nakalipas -- kung na-clone mo itong mas kamakailan pa kaysa sa iyon, makikita mo lamang ang iyong unang lokal na commit.

[TIP]
.Isipin ang reflog bilang bersyon ng Git sa kasaysayan ng shell
====
Kung ikaw ay mayroong UNIX o Linux na karanasan, maaari mong isipin na ang iyong reflog bilang bersyon ng Git sa kasaysayan ng shell, na nagpapahiwatig na kung ano ang naroroon ay malinaw na may kaugnayan lamang para sa iyo at iyong ``sesyon'', at walang kinalaman sa sinuman na maaaring nagtratrabaho sa parehong makina.
====

==== Ancestry References

The other main way to specify a commit is via its ancestry.
If you place a `^` (caret) at the end of a reference, Git resolves it to mean the parent of that commit.
Suppose you look at the history of your project:

[source,console]
----
$ git log --pretty=format:'%h %s' --graph
* 734713b fixed refs handling, added gc auto, updated tests
*   d921970 Merge commit 'phedders/rdocs'
|\
| * 35cfb2b Some rdoc changes
* | 1c002dd added some blame and merge stuff
|/
* 1c36188 ignore *.gem
* 9b29157 add open3_detach to gemspec file list
----

Then, you can see the previous commit by specifying `HEAD^`, which means ``the parent of HEAD'':

[source,console]
----
$ git show HEAD^
commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'
----

[NOTE]
.Escaping the caret on Windows
====

On Windows in `cmd.exe`, `^` is a special character and needs to be treated differently. You can either double it or put the commit reference in quotes:

[source,console]
----
$ git show HEAD^     # will NOT work on Windows
$ git show HEAD^^    # OK
$ git show "HEAD^"   # OK
----

====

You can also specify a number after the `^` – for example, `d921970^2` means ``the second parent of d921970.''
This syntax is useful only for merge commits, which have more than one parent.
The first parent is the branch you were on when you merged, and the second is the commit on the branch that you merged in:

[source,console]
----
$ git show d921970^
commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff

$ git show d921970^2
commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548
Author: Paul Hedderly <paul+git@mjr.org>
Date:   Wed Dec 10 22:22:03 2008 +0000

    Some rdoc changes
----

The other main ancestry specification is the `~` (tilde).
This also refers to the first parent, so `HEAD~` and `HEAD^` are equivalent.
The difference becomes apparent when you specify a number.
`HEAD~2` means ``the first parent of the first parent,'' or ``the grandparent'' -- it traverses the first parents the number of times you specify.
For example, in the history listed earlier, `HEAD~3` would be

[source,console]
----
$ git show HEAD~3
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner <tom@mojombo.com>
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem
----

This can also be written `HEAD^^^`, which again is the first parent of the first parent of the first parent:

[source,console]
----
$ git show HEAD^^^
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner <tom@mojombo.com>
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem
----

You can also combine these syntaxes -- you can get the second parent of the previous reference (assuming it was a merge commit) by using `HEAD~3^2`, and so on.

[[_commit_ranges]]
==== Commit Ranges

Now that you can specify individual commits, let’s see how to specify ranges of commits.
This is particularly useful for managing your branches -- if you have a lot of branches, you can use range specifications to answer questions such as, ``What work is on this branch that I haven’t yet merged into my main branch?''

===== Double Dot

The most common range specification is the double-dot syntax.
This basically asks Git to resolve a range of commits that are reachable from one commit but aren’t reachable from another.
For example, say you have a commit history that looks like <<double_dot>>.

[[double_dot]]
.Example history for range selection.
image::images/double-dot.png[Example history for range selection.]

Say you want to see what is in your `experiment` branch that hasn’t yet been merged into your `master` branch.
You can ask Git to show you a log of just those commits with `master..experiment` -- that means ``all commits reachable from experiment that aren’t reachable from master.''
For the sake of brevity and clarity in these examples, the letters of the commit objects from the diagram are used in place of the actual log output in the order that they would display:

[source,console]
----
$ git log master..experiment
D
C
----

If, on the other hand, you want to see the opposite -- all commits in `master` that aren’t in `experiment` -- you can reverse the branch names.
`experiment..master` shows you everything in `master` not reachable from `experiment`:

[source,console]
----
$ git log experiment..master
F
E
----

This is useful if you want to keep the `experiment` branch up to date and preview what you’re about to merge.
Another frequent use of this syntax is to see what you’re about to push to a remote:

[source,console]
----
$ git log origin/master..HEAD
----

This command shows you any commits in your current branch that aren’t in the `master` branch on your `origin` remote.
If you run a `git push` and your current branch is tracking `origin/master`, the commits listed by `git log origin/master..HEAD` are the commits that will be transferred to the server.
You can also leave off one side of the syntax to have Git assume `HEAD`.
For example, you can get the same results as in the previous example by typing `git log origin/master..` -- Git substitutes `HEAD` if one side is missing.

===== Multiple Points

The double-dot syntax is useful as a shorthand, but perhaps you want to specify more than two branches to indicate your revision, such as seeing what commits are in any of several branches that aren’t in the branch you’re currently on.
Git allows you to do this by using either the `^` character or `--not` before any reference from which you don’t want to see reachable commits.
Thus, the following three commands are equivalent:

[source,console]
----
$ git log refA..refB
$ git log ^refA refB
$ git log refB --not refA
----

This is nice because with this syntax you can specify more than two references in your query, which you cannot do with the double-dot syntax.
For instance, if you want to see all commits that are reachable from `refA` or `refB` but not from `refC`, you can use either of:

[source,console]
----
$ git log refA refB ^refC
$ git log refA refB --not refC
----

This makes for a very powerful revision query system that should help you figure out what is in your branches.

[[_triple_dot]]
===== Triple Dot

The last major range-selection syntax is the triple-dot syntax, which specifies all the commits that are reachable by _either_ of two references but not by both of them.
Look back at the example commit history in <<double_dot>>.
If you want to see what is in `master` or `experiment` but not any common references, you can run:

[source,console]
----
$ git log master...experiment
F
E
D
C
----

Again, this gives you normal `log` output but shows you only the commit information for those four commits, appearing in the traditional commit date ordering.

A common switch to use with the `log` command in this case is `--left-right`, which shows you which side of the range each commit is in.
This helps make the output more useful:

[source,console]
----
$ git log --left-right master...experiment
< F
< E
> D
> C
----

With these tools, you can much more easily let Git know what commit or commits you want to inspect.
